<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>THREE.js Sphere New</title>
    <script src="objectDefaultFiles/object.js"></script>
    <script src="objectDefaultFiles/pep.min.js"></script>
    <script src="objectDefaultFiles/envelopeContents.js"></script>
    <script src="resources/three.js"></script>
    <script src="resources/utils/SceneUtils.js"></script>
    <script src="resources/THREE.MeshLine.js"></script>

</head>
<body>
<script>
    var camera, scene, renderer;
    var threejsContainerObj;
    var realityInterface;
    var checkpointbaseGrounded, groundplaneContainerObj, gp_shadow, gp_checkpointDummy, heightLine;

    var isProjectionMatrixSet = false;
    var isGroundPlaneFound = false;

    var rendererWidth = screen.height;
    var rendererHeight = screen.width;
    var aspectRatio = rendererWidth / rendererHeight;

    var hue = 0;
    var saturation = 0.75;
    var lightness = 0.6;

    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    var cube;

    var materials = [
        new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors, shininess: 0 } ),
        new THREE.MeshBasicMaterial( { color: 0x000000, shading: THREE.FlatShading, wireframe: true, transparent: true } )
    ];

    window.addEventListener('load', function() {

        // create a fullscreen webgl renderer for the threejs content and add to the dom
        renderer = new THREE.WebGLRenderer( { alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( rendererWidth, rendererHeight );
        document.body.appendChild( renderer.domElement );

        // create a threejs camera and scene
        camera = new THREE.PerspectiveCamera( 70, aspectRatio, 1, 1000 );
        scene = new THREE.Scene();

        // create a parent 3D object to contain all the three js objects
        // we can apply the marker transform to this object and all of its
        // children objects will be affected
        threejsContainerObj = new THREE.Object3D();
        threejsContainerObj.matrixAutoUpdate = false;
        scene.add(threejsContainerObj);

        // Create Ground Plane container
        groundplaneContainerObj = new THREE.Object3D();
        groundplaneContainerObj.matrixAutoUpdate = false;
        groundplaneContainerObj.name = 'groundPlaneContainer';
        scene.add(groundplaneContainerObj);

        var geometry2 = new THREE.BoxGeometry( 10, 10, 10 );
        var material2 = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
        var cube = new THREE.Mesh( geometry2, material2 );
        threejsContainerObj.add( cube );
        cube.position.setZ(150);
        

        // light the scene with a combination of ambient and directional white light
        var ambLight = new THREE.AmbientLight(0x404040);
        scene.add(ambLight);
        var dirLight1 = new THREE.DirectionalLight(0xffffff, 1);
        dirLight1.position.set(100, 100, 100);
        scene.add(dirLight1);
        var dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight2.position.set(-100, -100, -100);
        scene.add(dirLight2);


        var loader = new THREE.ObjectLoader();

        loader.load(
            // resource URL
            "resources/models/KineticAR_Locator_01.json",

            // onLoad callback
            // Here the loaded data is assumed to be an object
            function ( obj ) {

                obj.traverse( function ( child ) {

                    if ( child instanceof THREE.Mesh ) {
                        child.materials = materials;

                        if (child.name === "LOCATOR___FLOATING"){

                            console.log('FOUND CHECKPOINT FBX');

                            checkpointbaseGrounded = child;
                        }
                    }
                } );
                
                // Add the loaded object to the scene
                threejsContainerObj.add( checkpointbaseGrounded );
                checkpointbaseGrounded.name = 'checkpoint';
                checkpointbaseGrounded.scale.set(10,10,10);
                checkpointbaseGrounded.position.setZ(150);
                checkpointbaseGrounded.position.setX(150);

                // add spotlight for the shadows
                var spotLight = new THREE.SpotLight(0xffffff);
                spotLight.position.set(-30, -30, 150);
                spotLight.castShadow = true;
                checkpointbaseGrounded.add(spotLight);

                setTimeout(function(){ addShadowAndHeightLine(); }, 3000);   // This is needed to avoid the initial setup frames where matrices are empty
            },

            // onProgress callback
            function ( xhr ) {
                console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
            },

            // onError callback
            function ( err ) {
                console.error( 'An error happened' );
            }
        );


        // make the frame fullscreen within the reality editor,
        // and subscribe to the modelview and projection matrices
        realityInterface = new RealityInterface();
        realityInterface.initNode('hue', 'node', -50, -50, undefined, 0);
        realityInterface.initNode('saturation', 'node', 0, 0, undefined, 0.75);
        realityInterface.initNode('lightness', 'node', 50, 50, undefined, 0.6);

        var _envelopeContents = new EnvelopeContents(realityInterface, document.body);

        realityInterface.onRealityInterfaceLoaded(function() {

            realityInterface.getScreenDimensions(function(width, height) {
                document.body.width = width + 'px';
                document.body.height = height + 'px';
                rendererWidth = width;
                rendererHeight = height;
                renderer.setSize( rendererWidth, rendererHeight );

                realityInterface.changeFrameSize(width, height);
            });

            realityInterface.subscribeToMatrix();
            realityInterface.setFullScreenOn();

            // whenever we receive new matrices from the editor, update the 3d scene
            realityInterface.addMatrixListener(renderScene);

            realityInterface.setMoveDelay(400);

            // uncomment this and include resources/navigation-arrow.js and resources/navigation-arrow.css to
            // show an arrow pointing towards the location of this frame when it leaves the camera view bounds
            // initNavigationArrow(document.querySelector('canvas'), realityInterface, true, touchDecider);

            realityInterface.registerTouchDecider(touchDecider);

            realityInterface.addGroundPlaneMatrixListener(groundPlaneCallback);

            realityInterface.addIsMovingListener(function(e) {
                if (e) {
                    console.log('red ball is moving');
                    hue = 0.3;
                    saturation = 1;
                    // lightness = 0.75;
                    moveProps();
                } else {
                    console.log('red ball is NOT moving');
                    hue = 0;
                    saturation = 0.75;
                    lightness = 0.6;
                }
            });

            realityInterface.addReadListener('hue', function(e) {
                hue = e.value;
            });

            realityInterface.addReadListener('saturation', function(e) {
                saturation = e.value;
            });

            realityInterface.addReadListener('lightness', function(e) {
                lightness = e.value;
            });


        });

    });

    function groundPlaneCallback(groundPlaneMatrix, projectionMatrix){

        if (isProjectionMatrixSet) {

            isGroundPlaneFound = true;
            setMatrixFromArray(groundplaneContainerObj.matrix, groundPlaneMatrix);  // update model view matrix
        }
    }

    function touchDecider(eventData) {

        console.log('TOUCH! ', eventData);
        
        //1. sets the mouse position with a coordinate system where the center
        //   of the screen is the origin
        mouse.x = ( eventData.x / window.innerWidth ) * 2 - 1;
        mouse.y = - ( eventData.y / window.innerHeight ) * 2 + 1;

        //2. set the picking ray from the camera position and mouse coordinates
        raycaster.setFromCamera( mouse, camera );

        //3. compute intersections
        var intersects = raycaster.intersectObject( checkpointbaseGrounded, true );
        
        // if (intersects.length > 0){
        //     var position = threejsContainerObj.worldToLocal(intersects[0].point);
        //     cube.position.set(position);
        // }

        console.log('intersects: ', intersects);

        return intersects.length > 0;
    }

    function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
            array[1], array[5], array[9], array[13],
            array[2], array[6], array[10], array[14],
            array[3], array[7], array[11], array[15]
        );
    }

    function renderScene(modelViewMatrix, projectionMatrix) {
        // only set the projection matrix for the camera 1 time, since it stays the same
        if (!isProjectionMatrixSet && projectionMatrix.length > 0) {
            setMatrixFromArray(camera.projectionMatrix, projectionMatrix);
            isProjectionMatrixSet = true;
        }

        if (isProjectionMatrixSet) { // don't turn into else statement, both can happen
            // update models with newest values from the reality editor
            checkpointbaseGrounded.material.color.setHSL( hue, saturation, lightness );
            //mesh.rotation.x += 0.005; // slow rotation, for aesthetic effect
            //mesh.rotation.y += 0.01;
            // update model view matrix
            setMatrixFromArray(threejsContainerObj.matrix, modelViewMatrix);
            // render the scene
            threejsContainerObj.visible = true;
            renderer.render( scene, camera );
        }
    }

    function addShadowAndHeightLine(){

        // Shadow

        let texture = new THREE.TextureLoader().load( "resources/textures/checkpointFloor.png" );
        let planeGeometry = new THREE.PlaneGeometry( 10, 10, 32 );
        let planeMaterial = new THREE.MeshBasicMaterial( {color: 0xffffff, opacity: 1.0, transparent: true, side: THREE.DoubleSide, map : texture} );
        gp_shadow = new THREE.Mesh( planeGeometry, planeMaterial );
        gp_shadow.rotateX(Math.PI/2);


        var geometry1 = new THREE.SphereGeometry( 3, 32, 32 );
        var material1 = new THREE.MeshBasicMaterial( {color: 0xffff00, transparent: true, opacity: 0} );
        gp_checkpointDummy = new THREE.Mesh( geometry1, material1 );

        checkpointbaseGrounded.add(gp_shadow);
        checkpointbaseGrounded.add(gp_checkpointDummy);
        //groundplaneContainerObj.attach(gp_shadow);

        THREE.SceneUtils.detach( gp_shadow, groundplaneContainerObj, scene );
        THREE.SceneUtils.attach( gp_shadow, scene, groundplaneContainerObj );

        gp_shadow.scale.set(5,5,5);

        // Height line

        let positionCheckpoint = new THREE.Vector3(0,0,0);
        checkpointbaseGrounded.getWorldPosition(positionCheckpoint);

        heightLine = new MeshLine();
        const positionsArray = [gp_shadow.position, gp_shadow.position];
        const geometryHeight = new THREE.Geometry();
        geometryHeight.vertices = positionsArray;
        heightLine.setGeometry( geometryHeight );

        let material = new MeshLineMaterial({
            color: new THREE.Color('white'),
            transparent:true,
            opacity: 0.5,
            dashArray: 0.1,
            //dashArray: 0,
            dashOffset: 0,
            dashRatio: 0.5,
            resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
            sizeAttenuation: true,
            lineWidth: 3,
            depthWrite: true,
            depthTest: true
            //near: camera.near,
            //far: camera.far
        });

        let heightLineMesh = new THREE.Mesh(heightLine.geometry, material);
        groundplaneContainerObj.add(heightLineMesh);

    }

    // Update shadow, update height line, reorient checkpoint
    function updateShadow(){

        if (gp_shadow && heightLine) {

            const gp_checkpointPos = checkpointbaseGrounded.position.clone();
            threejsContainerObj.localToWorld(gp_checkpointPos);
            groundplaneContainerObj.worldToLocal(gp_checkpointPos);

            gp_shadow.position.set(gp_checkpointPos.x, 0, gp_checkpointPos.z);
            gp_shadow.rotation.set(Math.PI/2,0,0);


            const positionsArray = [gp_shadow.position, gp_checkpointPos];

            const geometry = new THREE.Geometry();
            geometry.vertices = positionsArray;

            heightLine.setGeometry( geometry );

            /*
            const gp_rotation = groundplaneContainerObj.rotation.clone();
            mainContainerObj.worldToLocal(gp_rotation);

            checkpointbaseGrounded.rotation.set(gp_rotation);

            */

        }
    }

    function moveProps() {
        console.log('moveProps');
        if (isGroundPlaneFound) updateShadow();
    }

</script>
</body>
</html>

